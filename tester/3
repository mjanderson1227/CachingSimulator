from cache_builder import CacheBuilder
from address import Address
from math import ceil
import random

class Cache:
    rows: list[set[int]]
    hits: int
    compulsory_misses: int
    conflict_misses: int
    builder: CacheBuilder
    clock_cycles: int
    total_instructions: int

    def __init__(self, builder: CacheBuilder):
        self.rows = []
        self.hits = 0
        self.compulsory_misses = 0
        self.conflict_misses = 0
        self.builder = builder
        self.clock_cycles = 0
        self.total_instructions = 0
        self.blocks_filled = 0

        for _ in range(builder.number_rows):
            tag_set = set()
            self.rows.append(tag_set)

    # Formatting for output printing.
    def __repr__(self) -> str:
        FORMAT_OFFSET = 24
        format_string = lambda label, output: f'{label}: {"".join([" " for _ in range(FORMAT_OFFSET - len(label))])}{output}'

        total_accesses = self.compulsory_misses + self.hits + self.conflict_misses
        hit_rate = round((self.hits * 100) / total_accesses, 4)
        miss_rate = round(100 - hit_rate, 4)
        total_cache_size = self.builder.cache_size / 1024
        unused_kb = ( (self.builder.number_blocks-self.compulsory_misses) * (self.builder.block_size+self.builder.overhead) ) / 1024 * 1024
        use_percentage = round(unused_kb / total_cache_size, 2)
        waste = round(unused_kb * 0.09, 2)

        return '\n'.join([
            "***** CACHE SIMULATION RESULTS *****\n",
            format_string("Total Cache Accesses", f'{total_accesses}'),
            format_string("Cache Hits", f'{self.hits}'),
            format_string("Cache Misses", f'{self.conflict_misses + self.compulsory_misses}'),
            format_string("--- Compulsory Misses", f'{self.compulsory_misses}'),
            format_string("--- Conflict Misses", f'{self.conflict_misses}'),
            "\n***** *****  CACHE HIT & MISS RATE  ***** *****\n",
            format_string("Hit Rate", f'{hit_rate}%'),
            format_string("Miss Rate", f'{miss_rate}%'),
            format_string("CPI", f'{self.clock_cycles / self.total_instructions:.2f} Cycles/Instruction'),
            format_string("Unused Cache Space", f'{unused_kb:.2f} KB / {total_cache_size} KB = {use_percentage:}% Waste: ${waste}'),
            format_string("Unused cache blocks", f'{self.builder.number_blocks - self.blocks_filled}'),
            ])

    def access(self, address: Address, length: int, type: str):
        # Track the offset of each address that is accessed.
        current_offset = address.offset

        # Determine the addresses that the cache will access.
        addr_queue = [address]
        while current_offset + length > self.builder.block_size:
            next_address = Address(address.full + length, self.builder)
            addr_queue.append(next_address)
            current_offset -= self.builder.block_size

        # Go through the address queue and access each address.
        for current_location in addr_queue:
            current_row = self.rows[current_location.index]
            status = None

            if current_location.tag in current_row:
                self.hits += 1
                status = "hit"
            elif len(current_row) >= self.builder.associativity:
                self.conflict_misses += 1
                random_tag = random.choice(list(current_row))
                current_row.remove(random_tag)
                status = "miss"
                self.blocks_filled += 1
            else:
                self.compulsory_misses += 1
                status = "miss"
                self.blocks_filled += 1

            # Calculating CPI.
            if status == "hit":
                self.clock_cycles += 1
            else:
                DATA_BUS_WIDTH = 32
                mem_reads = ceil(self.builder.block_size / DATA_BUS_WIDTH)
                self.clock_cycles += 4 * mem_reads

            # Check if the type is instruction or data.
            if type == "I":
                self.clock_cycles += 1
                self.total_instructions += 1
            else:
                self.clock_cycles += 2

            current_row.add(current_location.tag)
